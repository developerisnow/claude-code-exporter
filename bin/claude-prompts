#!/usr/bin/env node

const ClaudePromptExporter = require('../lib/index');
const path = require('path');
const fs = require('fs');

const HELP_TEXT = `
Claude Code Prompt Exporter v${ClaudePromptExporter.getVersion()}

Export your Claude Code session prompts to markdown files.

USAGE:
  claude-prompts [options] [project-path] [output-dir]

ARGUMENTS:
  project-path    Path to your project (default: current directory)
  output-dir      Output directory for markdown files (default: ./claude-prompts)

OPTIONS:
  -h, --help             Show this help message
  -v, --version          Show version number
  -V, --verbose          Enable verbose output
  --list                 List available sessions without exporting
  
  Export Modes:
  -p, --prompts          Export user prompts only (default)
  -o, --outputs          Export assistant outputs only
  -f, --full             Export full conversations
  
  Export Formats:
  -m, --markdown         Export as Markdown (default)
  -j, --json             Export as JSON
  --all-formats          Export in both Markdown and JSON
  
  Aggregation Options:
  --aggregate            Aggregate sessions across projects
  --nested               Create nested directory structure
  --both-dirs            Process both Claude directories
  --period PERIOD        Filter by time period (e.g., 7d, 2w, 3m, 1y)
  --periodGroup GROUP    Group by period (d, w, m, y)
  
  Other Options:
  -q, --quiet            Suppress all output except errors
  --no-interactive       Disable interactive prompts, use defaults
  --claude-home DIR      Specify Claude home directory
  --timeout SECONDS      Timeout for interactive prompts (default: 10)

EXAMPLES:
  claude-prompts                              # Export user prompts (default)
  claude-prompts --full /path/to/project     # Export full conversations
  claude-prompts --outputs-only ./exports    # Export only assistant outputs
  claude-prompts . ./exports                 # Export to custom directory
  claude-prompts --list /path/to/project     # List sessions only
  claude-prompts -V /path/to/project         # Verbose output
  claude-prompts --claude-home ~/.config/claude /path/to/project

For more information, visit: https://github.com/developerisnow/claude-code-exporter
`;

function parseArgs(args) {
  const options = {
    help: false,
    version: false,
    verbose: false,
    quiet: false,
    list: false,
    prompts: false,
    outputs: false,
    full: false,
    markdown: false,
    json: false,
    allFormats: false,
    interactive: true,
    timeout: 10000,
    claudeHome: null,
    projectPath: process.cwd(),
    outputDir: './claude-prompts',
    aggregate: false,
    nested: false,
    bothDirs: false,
    period: null,
    periodGroup: null
  };

  const positionalArgs = [];

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    if (arg === '-h' || arg === '--help') {
      options.help = true;
    } else if (arg === '-v' || arg === '--version') {
      options.version = true;
    } else if (arg === '-V' || arg === '--verbose') {
      options.verbose = true;
    } else if (arg === '-q' || arg === '--quiet') {
      options.quiet = true;
    } else if (arg === '--list') {
      options.list = true;
    } else if (arg === '-p' || arg === '--prompts') {
      options.prompts = true;
    } else if (arg === '-o' || arg === '--outputs' || arg === '--outputs-only') {
      options.outputs = true;
    } else if (arg === '-f' || arg === '--full') {
      options.full = true;
    } else if (arg === '-m' || arg === '--markdown') {
      options.markdown = true;
    } else if (arg === '-j' || arg === '--json') {
      options.json = true;
    } else if (arg === '--all-formats') {
      options.allFormats = true;
    } else if (arg === '--no-interactive') {
      options.interactive = false;
    } else if (arg === '--timeout') {
      if (i + 1 < args.length && !args[i + 1].startsWith('-')) {
        options.timeout = parseInt(args[++i]) * 1000;
      } else {
        console.error('Error: --timeout requires a number in seconds');
        process.exit(1);
      }
    } else if (arg === '--claude-home') {
      if (i + 1 < args.length && !args[i + 1].startsWith('-')) {
        options.claudeHome = args[++i];
      } else {
        console.error('Error: --claude-home requires a directory path');
        process.exit(1);
      }
    } else if (arg === '--aggregate') {
      options.aggregate = true;
    } else if (arg === '--nested') {
      options.nested = true;
    } else if (arg === '--both-dirs') {
      options.bothDirs = true;
    } else if (arg === '--period' || arg.startsWith('--period=')) {
      if (arg.includes('=')) {
        options.period = arg.split('=')[1];
      } else if (i + 1 < args.length && !args[i + 1].startsWith('-')) {
        options.period = args[++i];
      } else {
        console.error('Error: --period requires a time period (e.g., 7d, 2w, 3m, 1y)');
        process.exit(1);
      }
    } else if (arg === '--periodGroup' || arg.startsWith('--periodGroup=')) {
      if (arg.includes('=')) {
        options.periodGroup = arg.split('=')[1];
      } else if (i + 1 < args.length && !args[i + 1].startsWith('-')) {
        options.periodGroup = args[++i];
      } else {
        console.error('Error: --periodGroup requires a group type (d, w, m, y)');
        process.exit(1);
      }
    } else if (!arg.startsWith('-')) {
      positionalArgs.push(arg);
    }
  }

  // Assign positional arguments
  if (positionalArgs.length > 0) {
    options.projectPath = positionalArgs[0];
  } else {
    // Default to aggregate + nested mode when no project path provided
    options.aggregate = true;
    options.nested = true;
    options.bothDirs = true;
  }
  if (positionalArgs.length > 1) {
    options.outputDir = positionalArgs[1];
  }

  return options;
}

function main() {
  const args = process.argv.slice(2);
  const options = parseArgs(args);

  if (options.help) {
    console.log(HELP_TEXT);
    process.exit(0);
  }

  if (options.version) {
    console.log(`claude-code-exporter v${ClaudePromptExporter.getVersion()}`);
    process.exit(0);
  }

  // Validate mutually exclusive options
  const modeCount = [options.prompts, options.outputs, options.full].filter(Boolean).length;
  if (modeCount > 1) {
    console.error('Error: Only one export mode can be specified');
    process.exit(1);
  }

  const formatCount = [options.markdown, options.json, options.allFormats].filter(Boolean).length;
  if (formatCount > 1) {
    console.error('Error: Only one format option can be specified');
    process.exit(1);
  }

  // Determine export mode from CLI flags
  let exportMode = null;
  if (options.prompts) {
    exportMode = ClaudePromptExporter.ExportMode.PROMPTS_ONLY;
  } else if (options.outputs) {
    exportMode = ClaudePromptExporter.ExportMode.OUTPUTS_ONLY;
  } else if (options.full) {
    exportMode = ClaudePromptExporter.ExportMode.FULL_CONVERSATION;
  }

  // Determine export format
  let exportFormat = ClaudePromptExporter.ExportFormat.MARKDOWN;
  if (options.json) {
    exportFormat = ClaudePromptExporter.ExportFormat.JSON;
  } else if (options.allFormats) {
    exportFormat = ClaudePromptExporter.ExportFormat.BOTH;
  }

  try {
    // Resolve paths
    const outputDir = path.resolve(options.outputDir);

    // For aggregate mode, we need a dummy project path
    const projectPath = options.aggregate ? process.cwd() : path.resolve(options.projectPath);

    // Debug logging
    if (options.verbose) {
      console.log(`[DEBUG] CLI options: aggregate=${options.aggregate}, nested=${options.nested}, periodGroup=${options.periodGroup}`);
    }

    // Create exporter instance
    const exporter = new ClaudePromptExporter(projectPath, { 
      verbose: options.verbose,
      claudeHome: options.claudeHome,
      exportMode: exportMode,
      exportFormat: exportFormat,
      interactive: options.interactive,
      timeout: options.timeout,
      aggregate: options.aggregate,
      nested: options.nested,
      bothDirs: options.bothDirs,
      period: options.period,
      periodGroup: options.periodGroup
    });

    // Prompt for mode and format if not specified
    if (!exportMode && !options.list && options.interactive) {
      exportMode = exporter.promptForExportMode();
      exporter.options.exportMode = exportMode;
    } else if (exportMode) {
      exporter.options.exportMode = exportMode;
    } else {
      // Default to prompts only for non-interactive mode
      exportMode = ClaudePromptExporter.ExportMode.PROMPTS_ONLY;
      exporter.options.exportMode = exportMode;
    }
    
    if (!options.list && options.interactive && !options.json && !options.markdown && !options.allFormats) {
      exportFormat = exporter.promptForExportFormat();
      exporter.options.exportFormat = exportFormat;
    } else {
      exporter.options.exportFormat = exportFormat;
    }

    const modeText = {
      [ClaudePromptExporter.ExportMode.PROMPTS_ONLY]: 'User Prompts',
      [ClaudePromptExporter.ExportMode.FULL_CONVERSATION]: 'Full Conversations',
      [ClaudePromptExporter.ExportMode.OUTPUTS_ONLY]: 'Assistant Outputs'
    }[exportMode || ClaudePromptExporter.ExportMode.PROMPTS_ONLY];

    if (!options.quiet) {
      console.log(`Claude Session Exporter (${modeText})\n`);
    }

    // Validate project path exists
    if (!fs.existsSync(projectPath)) {
      throw new Error(`Project path does not exist: ${projectPath}`);
    }

    if (!options.quiet) {
      console.log(`Project: ${projectPath}`);
    }

    if (options.list) {
      // List mode - just show available sessions
      const sessions = exporter.extractMessages();
      const itemName = exportMode === ClaudePromptExporter.ExportMode.OUTPUTS_ONLY ? 'output' : 
                       exportMode === ClaudePromptExporter.ExportMode.FULL_CONVERSATION ? 'message' : 'prompt';
      console.log(`\nFound ${sessions.length} session(s) with ${itemName}s:\n`);
      
      sessions.forEach(({ sessionId, messages, stats }) => {
        const firstMessage = messages[0].content.split('\n')[0].slice(0, 60) + '...';
        console.log(`  ${sessionId}`);
        
        if (exportMode === ClaudePromptExporter.ExportMode.FULL_CONVERSATION) {
          console.log(`    Messages: ${messages.length} (${stats.userMessages} user, ${stats.assistantMessages} assistant)`);
        } else {
          console.log(`    ${itemName.charAt(0).toUpperCase() + itemName.slice(1)}s: ${messages.length}`);
        }
        
        console.log(`    First: "${firstMessage}"`);
        console.log();
      });
    } else {
      // Export mode
      if (!options.quiet) {
        console.log(`Output:  ${outputDir}\n`);
      }
      const result = exporter.export(outputDir);
      
      if (result.sessionsExported === 0 && !options.quiet) {
        console.log('\nNo sessions found to export.');
      }
    }

  } catch (error) {
    console.error(`\nError: ${error.message}`);
    
    if (options.verbose && error.stack) {
      console.error('\nStack trace:');
      console.error(error.stack);
    }
    
    process.exit(1);
  }
}

// Check if running as MCP server
if (process.argv[2] === 'mcp') {
  // Launch MCP server
  const { spawn } = require('child_process');
  const path = require('path');
  const mcpPath = path.join(__dirname, '..', 'mcp', 'server.js');
  const child = spawn('node', [mcpPath], {
    stdio: 'inherit',
    env: process.env
  });
  child.on('exit', (code) => process.exit(code || 0));
} else {
  // Run the CLI
  main();
}
